/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Concepts of buffers.
 */

#ifndef SK_BUFFER_RANGE_BUFFER_HXX_INCLUDED
#define SK_BUFFER_RANGE_BUFFER_HXX_INCLUDED

#include <cstddef>
#include <ranges>
#include <span>

#include <sk/buffer.hxx>

namespace sk {

    /*************************************************************************
     *
     * range buffer: a buffer that exposes a range of `T` as a writable buffer,
     * or a range of `const T` as a readable buffer.  This can be used to wrap
     * existing ranges, e.g. to write directly into the destination.
     *
     */

    /*************************************************************************
     *
     * readable_range_buffer: a readable_buffer that exposes data from a
     * contiguous range.
     */
    template <std::ranges::contiguous_range Range>
    struct readable_range_buffer {
        using value_type =
            std::remove_const_t<std::ranges::range_value_t<Range>>;
        using const_value_type = std::add_const_t<value_type>;
        using size_type = std::ranges::range_size_t<Range>;

        std::span<const_value_type> read_window;

        readable_range_buffer(Range const &range) : read_window(range) {}

        template <std::ranges::contiguous_range InRange>
        auto read(InRange &&buf) -> size_type
            requires std::same_as<value_type,
                                  std::ranges::range_value_t<InRange>> {
            auto can_read =
                std::min(std::ranges::size(buf), read_window.size());

            auto will_read = read_window.subspan(0, can_read);
            std::ranges::copy(will_read, std::ranges::begin(buf));
            discard(can_read);
            return can_read;
        }

        auto readable_ranges() -> std::vector<std::span<const_value_type>> {
            return {read_window};
        }

        auto discard(size_type n) -> size_type {
            auto will_discard = std::min(n, read_window.size());
            read_window = read_window.subspan(will_discard);
            return will_discard;
        }
    };

    static_assert(
        readable_buffer_of<readable_range_buffer<std::span<char>>, char>);

    // Create a readable_range_buffer from a range.
    template <std::ranges::contiguous_range Range>
    auto make_readable_range_buffer(Range &&range) {
        using range_type = std::remove_reference_t<decltype(range)>;
        return readable_range_buffer<range_type>(range);
    }

    /*************************************************************************
     *
     * writable_range_buffer: a writable_buffer that exposes data from a
     * contiguous range.
     */
    template <std::ranges::contiguous_range Range>
    struct writable_range_buffer {
        using value_type = std::ranges::range_value_t<Range>;
        using const_value_type = std::add_const_t<value_type>;
        using size_type = typename std::span<value_type>::size_type;

        std::span<value_type> write_window;

        writable_range_buffer(Range &range) : write_window(range) {}

        // clang-format off
        template<std::ranges::contiguous_range InRange>
        auto write(InRange &&buf) -> size_type
            requires std::same_as<
                const_value_type,
                std::add_const_t<std::ranges::range_value_t<InRange>>
            > {

            auto can_write =
                std::min(write_window.size(), std::ranges::size(buf));
            auto will_write = buf | std::ranges::views::take(can_write);
            std::ranges::copy(will_write, write_window.begin());
            commit(can_write);
            return can_write;
        }
        // clang-format on

        auto writable_ranges() -> std::vector<std::span<value_type>> {
            return {write_window};
        }

        auto commit(size_type n) -> size_type {
            auto will_commit = std::min(write_window.size(), n);
            write_window = write_window.subspan(will_commit);
            return will_commit;
        }
    };

    static_assert(writable_buffer<writable_range_buffer<std::span<char>>>);

    // Create a writable_range_buffer from a range.
    template <std::ranges::contiguous_range Range>
    auto make_writable_range_buffer(Range &&range) {
        using range_type = std::remove_reference_t<decltype(range)>;
        return writable_range_buffer<range_type>(range);
    }

} // namespace sk

#endif // SK_BUFFER_RANGE_BUFFER_HXX_INCLUDED
